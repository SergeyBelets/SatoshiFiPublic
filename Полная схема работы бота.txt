Вы правы, я дал неполное описание. Вот полная структура бота без сокращений:
Полная структура Telegram-бота "Классный руководитель"
1. Серверная инфраструктура (AWS)
AWS EC2 Instance
Instance Type: t3.micro
Operating System: Ubuntu 22.04 LTS
Security Group: порты 22 (SSH), 80 (HTTP), 443 (HTTPS)
Public IP: ip-172-31-46-192
Region: us-east-1
Системные сервисы
# /etc/systemd/system/classroom-bot.service
[Unit]
Description=Classroom Bot
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/opt/classroom-bot
Environment=PATH=/opt/classroom-bot/venv/bin
ExecStart=/opt/classroom-bot/venv/bin/python /opt/classroom-bot/bot.py
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
Файловая структура
/opt/classroom-bot/
├── bot.py                 # Основной код бота
├── .env                   # Переменные окружения
├── classroom.db           # База данных SQLite
├── venv/                  # Виртуальное окружение Python
└── requirements.txt       # Зависимости Python
2. Telegram Bot Configuration
Bot Token и настройки
Bot: @Class4ManagementBot
Bot Token: 8071154944:AAGn5xwhNYQdKwHAsG_FPcnQQSXt9jcmiBg
Creator: @BotFather
Webhook: отключен (используется polling)
Переменные окружения (.env)
BOT_TOKEN=8071154944:AAGn5xwhNYQdKwHAsG_FPcnQQSXt9jcmiBg
DEVELOPER_ID=95143189
3. База данных (SQLite)
Структура таблиц
CREATE TABLE users (
    telegram_id INTEGER PRIMARY KEY,
    username TEXT,
    full_name TEXT,
    role TEXT DEFAULT 'pending',
    registered_at TIMESTAMP
);

CREATE TABLE schedule (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    day_of_week INTEGER,
    lesson_number INTEGER,
    start_time TEXT,
    subject TEXT,
    requirements TEXT,
    created_at TIMESTAMP
);

CREATE TABLE teacher_messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    from_parent_id INTEGER,
    parent_name TEXT,
    message_text TEXT,
    received_at TIMESTAMP
);

CREATE TABLE parent_messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    to_parent_id INTEGER,
    from_teacher_id INTEGER,
    teacher_name TEXT,
    message_text TEXT,
    sent_at TIMESTAMP
);

CREATE TABLE sent_announcements (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    from_teacher_id INTEGER,
    teacher_name TEXT,
    announcement_text TEXT,
    sent_at TIMESTAMP,
    recipients_count INTEGER
);

CREATE TABLE sent_homework (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    from_teacher_id INTEGER,
    teacher_name TEXT,
    homework_text TEXT,
    sent_at TIMESTAMP,
    recipients_count INTEGER
);

CREATE TABLE message_recipients (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    message_type TEXT,
    message_id INTEGER,
    recipient_id INTEGER,
    sent_successfully BOOLEAN,
    sent_at TIMESTAMP
);
4. Полный код бота
#!/usr/bin/env python3
import os
import sqlite3
from datetime import datetime, timedelta
from dotenv import load_dotenv
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

load_dotenv()
BOT_TOKEN = os.getenv('BOT_TOKEN')
DEVELOPER_ID = int(os.getenv('DEVELOPER_ID', 0))

def init_db():
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS users (
        telegram_id INTEGER PRIMARY KEY,
        username TEXT,
        full_name TEXT,
        role TEXT DEFAULT 'pending',
        registered_at TIMESTAMP
    )''')
    c.execute('''CREATE TABLE IF NOT EXISTS schedule (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        day_of_week INTEGER,
        lesson_number INTEGER,
        start_time TEXT,
        subject TEXT,
        requirements TEXT,
        created_at TIMESTAMP
    )''')
    c.execute('''CREATE TABLE IF NOT EXISTS teacher_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        from_parent_id INTEGER,
        parent_name TEXT,
        message_text TEXT,
        received_at TIMESTAMP
    )''')
    c.execute('''CREATE TABLE IF NOT EXISTS parent_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        to_parent_id INTEGER,
        from_teacher_id INTEGER,
        teacher_name TEXT,
        message_text TEXT,
        sent_at TIMESTAMP
    )''')
    c.execute('''CREATE TABLE IF NOT EXISTS sent_announcements (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        from_teacher_id INTEGER,
        teacher_name TEXT,
        announcement_text TEXT,
        sent_at TIMESTAMP,
        recipients_count INTEGER
    )''')
    c.execute('''CREATE TABLE IF NOT EXISTS sent_homework (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        from_teacher_id INTEGER,
        teacher_name TEXT,
        homework_text TEXT,
        sent_at TIMESTAMP,
        recipients_count INTEGER
    )''')
    c.execute('''CREATE TABLE IF NOT EXISTS message_recipients (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        message_type TEXT,
        message_id INTEGER,
        recipient_id INTEGER,
        sent_successfully BOOLEAN,
        sent_at TIMESTAMP
    )''')
    conn.commit()
    conn.close()

def get_user_role(user_id):
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute("SELECT role FROM users WHERE telegram_id = ?", (user_id,))
    result = c.fetchone()
    conn.close()
    return result[0] if result else None

def get_user_name(user_id):
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute("SELECT full_name, username FROM users WHERE telegram_id = ?", (user_id,))
    result = c.fetchone()
    conn.close()
    if result:
        return result[0] or result[1] or f"ID{user_id}"
    return f"ID{user_id}"

def get_main_menu(role):
    if role == 'developer':
        keyboard = [['👥 Пользователи', '📊 Статистика'], ['👨‍🏫 Управление', '📢 Рассылка']]
    elif role == 'teacher':
        keyboard = [
            ['📢 Создать объявление', '📚 Создать домашнее задание'],
            ['📢 Просмотр объявлений', '📚 Просмотр домашних заданий'],
            ['📋 Управление сообщениями', '📅 Расписание'],
            ['📊 Статистика класса']
        ]
    elif role == 'parent':
        keyboard = [
            ['📢 Объявления', '📚 Домашние задания'], 
            ['📅 Расписание', '✍️ Написать учителю'],
            ['↩️ Ответить учителю', '🔙 Назад']
        ]
    else:
        return None
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

def clear_user_context(context):
    context.user_data.pop('waiting_for', None)
    context.user_data.pop('selecting_parent', None)
    context.user_data.pop('parent_list', None)
    context.user_data.pop('target_parent_id', None)
    context.user_data.pop('messages_for_forwarding', None)
    context.user_data.pop('replying_to_teacher_id', None)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = user.id
    
    clear_user_context(context)
    
    await update.message.reply_text(f"🆔 Ваш Telegram ID: {user_id}")
    
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute('SELECT role FROM users WHERE telegram_id = ?', (user_id,))
    existing = c.fetchone()
    
    if existing:
        role = existing[0]
    else:
        role = 'developer' if user_id == DEVELOPER_ID else 'pending'
        c.execute("INSERT INTO users VALUES (?, ?, ?, ?, ?)",
                  (user_id, user.username, user.full_name, role, datetime.now()))
        conn.commit()
        
        if role == 'pending' and DEVELOPER_ID != user_id:
            try:
                await context.bot.send_message(
                    DEVELOPER_ID,
                    f"🆕 Новый пользователь:\nID: {user_id}\nИмя: {user.full_name or 'Не указано'}\nUsername: @{user.username or 'нет'}\n\n/make_teacher {user_id} - назначить учителем\n/make_parent {user_id} - подтвердить родителя"
                )
            except:
                pass
    
    conn.close()
    
    if role == 'developer':
        await update.message.reply_text("Сброс меню...", reply_markup=ReplyKeyboardRemove())
        markup = get_main_menu('developer')
        text = "🎛 Админ-панель активна\nВы разработчик системы"
        await update.message.reply_text(text, reply_markup=markup)
    elif role == 'teacher':
        text = "👨‍🏫 Добро пожаловать, учитель!\nИспользуйте меню для управления классом"
        markup = get_main_menu('teacher')
        await update.message.reply_text(text, reply_markup=markup)
    elif role == 'parent':
        text = "👨‍👩‍👧 Добро пожаловать, родитель!\nВы будете получать объявления и домашние задания"
        markup = get_main_menu('parent')
        await update.message.reply_text(text, reply_markup=markup)
    else:
        text = "👋 Добро пожаловать!\nОжидайте подтверждения от администратора"
        await update.message.reply_text(text)

async def show_schedule(update: Update, context: ContextTypes.DEFAULT_TYPE):
    today = datetime.now()
    tomorrow = today + timedelta(days=1)
    day_names = ['понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота', 'воскресенье']
    
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    
    today_dow = today.weekday()
    c.execute("SELECT lesson_number, start_time, subject, requirements FROM schedule WHERE day_of_week = ? ORDER BY lesson_number", (today_dow,))
    today_lessons = c.fetchall()
    
    tomorrow_dow = tomorrow.weekday()
    c.execute("SELECT lesson_number, start_time, subject, requirements FROM schedule WHERE day_of_week = ? ORDER BY lesson_number", (tomorrow_dow,))
    tomorrow_lessons = c.fetchall()
    
    conn.close()
    
    def format_lessons(lessons):
        if not lessons:
            return "Уроков нет"
        formatted = ""
        for lesson in lessons:
            lesson_num, time_slot, subject, requirements = lesson
            req_text = f" ({requirements})" if requirements else ""
            formatted += f"{lesson_num}. {time_slot} - {subject}{req_text}\n"
        return formatted
    
    text = f"📅 СЕГОДНЯ - {day_names[today_dow]} ({today.strftime('%d.%m')}):\n"
    text += format_lessons(today_lessons)
    
    text += f"\n📅 ЗАВТРА - {day_names[tomorrow_dow]} ({tomorrow.strftime('%d.%m')}):\n"
    text += format_lessons(tomorrow_lessons)
    
    await update.message.reply_text(text)

async def show_sent_announcements(update: Update, context: ContextTypes.DEFAULT_TYPE):
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute("SELECT id, teacher_name, announcement_text, sent_at, recipients_count FROM sent_announcements ORDER BY sent_at DESC LIMIT 10")
    announcements = c.fetchall()
    conn.close()
    
    if not announcements:
        await update.message.reply_text("📢 Отправленных объявлений пока нет")
        return
    
    text = "📢 Последние отправленные объявления:\n\n"
    
    for ann in announcements:
        ann_id, teacher_name, ann_text, sent_at, recipients = ann
        sent_time = datetime.fromisoformat(sent_at).strftime('%d.%m %H:%M')
        preview = (ann_text[:60] + '...') if len(ann_text) > 60 else ann_text
        text += f"🔹 ID{ann_id} | {teacher_name} ({sent_time})\n"
        text += f"Получателей: {recipients}\n"
        text += f"{preview}\n\n"
    
    await update.message.reply_text(text)

async def show_sent_homework(update: Update, context: ContextTypes.DEFAULT_TYPE):
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute("SELECT id, teacher_name, homework_text, sent_at, recipients_count FROM sent_homework ORDER BY sent_at DESC LIMIT 10")
    homework_list = c.fetchall()
    conn.close()
    
    if not homework_list:
        await update.message.reply_text("📚 Отправленных домашних заданий пока нет")
        return
    
    text = "📚 Последние отправленные домашние задания:\n\n"
    
    for hw in homework_list:
        hw_id, teacher_name, hw_text, sent_at, recipients = hw
        sent_time = datetime.fromisoformat(sent_at).strftime('%d.%m %H:%M')
        preview = (hw_text[:60] + '...') if len(hw_text) > 60 else hw_text
        text += f"🔹 ID{hw_id} | {teacher_name} ({sent_time})\n"
        text += f"Получателей: {recipients}\n"
        text += f"{preview}\n\n"
    
    await update.message.reply_text(text)

async def teacher_messages_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        ['💬 Сообщения от родителей', '✉️ Написать родителю'],
        ['📤 Переслать сообщение'],
        ['🔙 Назад']
    ]
    markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    await update.message.reply_text('📋 Управление сообщениями:', reply_markup=markup)

async def show_parent_messages(update: Update, context: ContextTypes.DEFAULT_TYPE):
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute("SELECT id, from_parent_id, parent_name, message_text, received_at FROM teacher_messages ORDER BY received_at DESC LIMIT 10")
    messages = c.fetchall()
    conn.close()
    
    if not messages:
        await update.message.reply_text("Нет сообщений от родителей")
        return
    
    text = "💬 Последние сообщения от родителей:\n\n"
    keyboard = []
    
    for msg in messages:
        msg_id, parent_id, parent_name, msg_text, received_at = msg
        received_time = datetime.fromisoformat(received_at).strftime('%d.%m %H:%M')
        preview = (msg_text[:50] + '...') if len(msg_text) > 50 else msg_text
        text += f"🔹 ID{msg_id} | {parent_name} ({received_time}):\n{preview}\n\n"
        keyboard.append([f"↩️ Ответить на ID{msg_id}"])
    
    keyboard.append(['🔙 Назад'])
    markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    await update.message.reply_text(text, reply_markup=markup)

async def show_teacher_messages_for_parent(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute("SELECT id, from_teacher_id, teacher_name, message_text, sent_at FROM parent_messages WHERE to_parent_id = ? ORDER BY sent_at DESC LIMIT 10", (user_id,))
    messages = c.fetchall()
    conn.close()
    
    if not messages:
        await update.message.reply_text("Нет сообщений от учителей")
        return
    
    text = "↩️ Последние сообщения от учителей:\n\n"
    keyboard = []
    
    for msg in messages:
        msg_id, teacher_id, teacher_name, msg_text, sent_at = msg
        sent_time = datetime.fromisoformat(sent_at).strftime('%d.%m %H:%M')
        preview = (msg_text[:50] + '...') if len(msg_text) > 50 else msg_text
        text += f"🔹 ID{msg_id} | {teacher_name} ({sent_time}):\n{preview}\n\n"
        keyboard.append([f"↩️ Ответить на ID{msg_id}"])
    
    keyboard.append(['🔙 Назад'])
    markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    await update.message.reply_text(text, reply_markup=markup)

async def select_parent_for_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute("SELECT telegram_id, full_name, username FROM users WHERE role = 'parent' ORDER BY full_name")
    parents = c.fetchall()
    conn.close()
    
    if not parents:
        await update.message.reply_text("Нет зарегистрированных родителей")
        return
    
    text = "Выберите родителя для отправки сообщения:\n\n"
    keyboard = []
    
    for parent in parents:
        parent_id, full_name, username = parent
        name = full_name or username or f"ID{parent_id}"
        keyboard.append([f"📨 {name}"])
    
    keyboard.append(['🔙 Назад'])
    markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    context.user_data['selecting_parent'] = True
    context.user_data['parent_list'] = {parent[0]: parent[1] or parent[2] or f"ID{parent[0]}" for parent in parents}
    
    await update.message.reply_text(text, reply_markup=markup)

async def show_messages_for_forwarding(update: Update, context: ContextTypes.DEFAULT_TYPE):
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute("SELECT id, from_parent_id, parent_name, message_text, received_at FROM teacher_messages ORDER BY received_at DESC LIMIT 15")
    messages = c.fetchall()
    conn.close()
    
    if not messages:
        await update.message.reply_text("Нет сообщений от родителей для пересылки")
        return
    
    text = "📤 Выберите сообщение для пересылки всем родителям:\n\n"
    keyboard = []
    
    for msg in messages:
        msg_id, parent_id, parent_name, msg_text, received_at = msg
        received_time = datetime.fromisoformat(received_at).strftime('%d.%m %H:%M')
        preview = (msg_text[:40] + '...') if len(msg_text) > 40 else msg_text
        text += f"🔹 {parent_name} ({received_time}):\n{preview}\n\n"
        keyboard.append([f"📤 Переслать от {parent_name}"])
    
    keyboard.append(['🔙 Назад'])
    markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    context.user_data['messages_for_forwarding'] = {msg[2]: {'id': msg[0], 'parent_name': msg[2], 'text': msg[3]} for msg in messages}
    
    await update.message.reply_text(text, reply_markup=markup)

async def handle_messages(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    user_id = update.effective_user.id
    user_role = get_user_role(user_id)
    
    if not user_role or user_role == 'pending':
        await update.message.reply_text("Ожидайте подтверждения от администратора")
        return
    
    waiting_for = context.user_data.get('waiting_for')
    
    # Проверка на кнопки меню во время ожидания ввода
    menu_buttons = ['📢 Создать объявление', '📚 Создать домашнее задание', '📢 Просмотр объявлений', 
                   '📚 Просмотр домашних заданий', '📋 Управление сообщениями', '📅 Расписание', 
                   '📊 Статистика класса', '💬 Сообщения от родителей', '✉️ Написать родителю',
                   '📤 Переслать сообщение', '📢 Объявления', '📚 Домашние задания', 
                   '✍️ Написать учителю', '↩️ Ответить учителю', '🔙 Назад']
    
    if waiting_for and text in menu_buttons:
        clear_user_context(context)
        await update.message.reply_text("❌ Операция отменена. Обрабатываю новую команду...")
        return
    
    # ОБРАБОТКА ОТВЕТА РОДИТЕЛЯ УЧИТЕЛЮ
    if waiting_for == 'replying_to_teacher' and user_role == 'parent':
        target_teacher_id = context.user_data.get('replying_to_teacher_id')
        parent_name = get_user_name(user_id)
        
        if target_teacher_id:
            try:
                await context.bot.send_message(target_teacher_id, f"↩️ Ответ родителя {parent_name}:\n\n{text}")
                await update.message.reply_text("✅ Ваш ответ отправлен учителю")
            except:
                await update.message.reply_text("❌ Не удалось отправить ответ")
            
            clear_user_context(context)
        return
    
    # Ответ родителя на конкретное сообщение учителя
    if text.startswith('↩️ Ответить на ID') and user_role == 'parent':
        try:
            msg_id = int(text.replace('↩️ Ответить на ID', ''))
            
            conn = sqlite3.connect('classroom.db')
            c = conn.cursor()
            c.execute("SELECT from_teacher_id, teacher_name, message_text FROM parent_messages WHERE id = ? AND to_parent_id = ?", (msg_id, user_id))
            message_data = c.fetchone()
            conn.close()
            
            if message_data:
                teacher_id, teacher_name, original_text = message_data
                preview = (original_text[:100] + '...') if len(original_text) > 100 else original_text
                
                context.user_data['waiting_for'] = 'replying_to_teacher'
                context.user_data['replying_to_teacher_id'] = teacher_id
                
                await update.message.reply_text(f"↩️ Отвечаю на сообщение от {teacher_name}:\n\n> {preview}\n\nВведите ваш ответ:")
            else:
                await update.message.reply_text("❌ Сообщение не найдено")
        except:
            await update.message.reply_text("❌ Ошибка при обработке ответа")
        return
    
    # Обработка выбора родителя для личного сообщения
    if context.user_data.get('selecting_parent') and text.startswith('📨'):
        parent_name = text.replace('📨 ', '')
        parent_list = context.user_data.get('parent_list', {})
        
        selected_parent_id = None
        for parent_id, name in parent_list.items():
            if name == parent_name:
                selected_parent_id = parent_id
                break
        
        if selected_parent_id:
            context.user_data['waiting_for'] = 'personal_message'
            context.user_data['target_parent_id'] = selected_parent_id
            context.user_data.pop('selecting_parent', None)
            context.user_data.pop('parent_list', None)
            await update.message.reply_text(f"Напишите сообщение для родителя {parent_name}:")
            return
    
    # Обработка пересылки сообщений
    if text.startswith('📤 Переслать от '):
        parent_name = text.replace('📤 Переслать от ', '')
        messages_for_forwarding = context.user_data.get('messages_for_forwarding', {})
        
        if parent_name in messages_for_forwarding:
            msg_info = messages_for_forwarding[parent_name]
            original_text = msg_info['text']
            
            conn = sqlite3.connect('classroom.db')
            c = conn.cursor()
            c.execute("SELECT telegram_id FROM users WHERE role = 'parent'")
            parents = c.fetchall()
            conn.close()
            
            sent_count = 0
            for parent in parents:
                try:
                    await context.bot.send_message(parent[0], f"📤 Пересланное сообщение от родителя {parent_name}:\n\n{original_text}")
                    sent_count += 1
                except:
                    pass
            
            await update.message.reply_text(f"✅ Сообщение от {parent_name} переслано {sent_count} родителям")
            clear_user_context(context)
            return
    
    # Ответ учителя на сообщение родителя
    if text.startswith('↩️ Ответить на ID') and user_role == 'teacher':
        try:
            msg_id = int(text.replace('↩️ Ответить на ID', ''))
            
            conn = sqlite3.connect('classroom.db')
            c = conn.cursor()
            c.execute("SELECT from_parent_id, parent_name, message_text FROM teacher_messages WHERE id = ?", (msg_id,))
            message_data = c.fetchone()
            conn.close()
            
            if message_data:
                parent_id, parent_name, original_text = message_data
                preview = (original_text[:100] + '...') if len(original_text) > 100 else original_text
                
                context.user_data['waiting_for'] = 'replying_to_message'
                context.user_data['target_parent_id'] = parent_id
                
                await update.message.reply_text(f"↩️ Отвечаю на сообщение от {parent_name}:\n\n> {preview}\n\nВведите ваш ответ:")
            else:
                await update.message.reply_text("❌ Сообщение не найдено")
        except:
            await update.message.reply_text("❌ Ошибка при обработке ответа")
        return
    
    # Обработка ввода текста
    if waiting_for == 'announcement' and user_role == 'teacher':
        teacher_name = get_user_name(user_id)
        conn = sqlite3.connect('classroom.db')
        c = conn.cursor()
        c.execute("SELECT telegram_id FROM users WHERE role = 'parent'")
        parents = c.fetchall()
        
        # Сохраняем объявление в базу
        c.execute("INSERT INTO sent_announcements (from_teacher_id, teacher_name, announcement_text, sent_at, recipients_count) VALUES (?, ?, ?, ?, ?)",
                  (user_id, teacher_name, text, datetime.now().isoformat(), len(parents)))
        announcement_id = c.lastrowid
        conn.commit()
        
        sent_count = 0
        for parent in parents:
            try:
                await context.bot.send_message(parent[0], f"📢 Объявление от учителя {teacher_name}:\n\n{text}")
                # Записываем успешную доставку
                c.execute("INSERT INTO message_recipients (message_type, message_id, recipient_id, sent_successfully, sent_at) VALUES (?, ?, ?, ?, ?)",
                         ('announcement', announcement_id, parent[0], True, datetime.now().isoformat()))
                sent_count += 1
            except:
                # Записываем неудачную доставку
                c.execute("INSERT INTO message_recipients (message_type, message_id, recipient_id, sent_successfully, sent_at) VALUES (?, ?, ?, ?, ?)",
                         ('announcement', announcement_id, parent[0], False, datetime.now().isoformat()))
        
        conn.commit()
        conn.close()
        
        await update.message.reply_text(f"✅ Объявление отправлено {sent_count} из {len(parents)} родителям")
        clear_user_context(context)
        return
        
    elif waiting_for == 'homework' and user_role == 'teacher':
        teacher_name = get_user_name(user_id)
        conn = sqlite3.connect('classroom.db')
        c = conn.cursor()
        c.execute("SELECT telegram_id FROM users WHERE role = 'parent'")
        parents = c.fetchall()
        
        # Сохраняем домашнее задание в базу
        c.execute("INSERT INTO sent_homework (from_teacher_id, teacher_name, homework_text, sent_at, recipients_count) VALUES (?, ?, ?, ?, ?)",
                  (user_id, teacher_name, text, datetime.now().isoformat(), len(parents)))
        homework_id = c.lastrowid
        conn.commit()
        
        sent_count = 0
        for parent in parents:
            try:
                await context.bot.send_message(parent[0], f"📚 Домашнее задание от учителя {teacher_name}:\n\n{text}")
                # Записываем успешную доставку
                c.execute("INSERT INTO message_recipients (message_type, message_id, recipient_id, sent_successfully, sent_at) VALUES (?, ?, ?, ?, ?)",
                         ('homework', homework_id, parent[0], True, datetime.now().isoformat()))
                sent_count += 1
            except:
                # Записываем неудачную доставку
                c.execute("INSERT INTO message_recipients (message_type, message_id, recipient_id, sent_successfully, sent_at) VALUES (?, ?, ?, ?, ?)",
                         ('homework', homework_id, parent[0], False, datetime.now().isoformat()))
        
        conn.commit()
        conn.close()
        
        await update.message.reply_text(f"✅ Домашнее задание отправлено {sent_count} из {len(parents)} родителям")
        clear_user_context(context)
        return
    
    elif waiting_for == 'personal_message' and user_role == 'teacher':
        teacher_name = get_user_name(user_id)
        target_parent_id = context.user_data.get('target_parent_id')
        
        if target_parent_id:
            try:
                await context.bot.send_message(target_parent_id, f"📨 Личное сообщение от учителя {teacher_name}:\n\n{text}")
                
                # Сохраняем сообщение для возможности ответа
                conn = sqlite3.connect('classroom.db')
                c = conn.cursor()
                c.execute("INSERT INTO parent_messages (to_parent_id, from_teacher_id, teacher_name, message_text, sent_at) VALUES (?, ?, ?, ?, ?)",
                         (target_parent_id, user_id, teacher_name, f"📨 Личное сообщение: {text}", datetime.now().isoformat()))
                conn.commit()
                conn.close()
                
                await update.message.reply_text("✅ Личное сообщение отправлено родителю")
            except:
                await update.message.reply_text("❌ Не удалось отправить сообщение")
            
            clear_user_context(context)
        return
    
    elif waiting_for == 'replying_to_message' and user_role == 'teacher':
        target_parent_id = context.user_data.get('target_parent_id')
        teacher_name = get_user_name(user_id)
        
        if target_parent_id:
            try:
                await context.bot.send_message(target_parent_id, f"↩️ Ответ учителя {teacher_name}:\n\n{text}")
                
                # Сохраняем ответ для возможности дальнейшего ответа
                conn = sqlite3.connect('classroom.db')
                c = conn.cursor()
                c.execute("INSERT INTO parent_messages (to_parent_id, from_teacher_id, teacher_name, message_text, sent_at) VALUES (?, ?, ?, ?, ?)",
                         (target_parent_id, user_id, teacher_name, f"↩️ Ответ: {text}", datetime.now().isoformat()))
                conn.commit()
                conn.close()
                
                await update.message.reply_text("✅ Ответ отправлен родителю")
            except:
                await update.message.reply_text("❌ Не удалось отправить ответ")
            
            clear_user_context(context)
        return
        
    elif waiting_for == 'message_to_teacher' and user_role == 'parent':
        user_name = update.effective_user.full_name or update.effective_user.username or str(user_id)
        
        conn = sqlite3.connect('classroom.db')
        c = conn.cursor()
        c.execute("INSERT INTO teacher_messages (from_parent_id, parent_name, message_text, received_at) VALUES (?, ?, ?, ?)",
                  (user_id, user_name, text, datetime.now().isoformat()))
        c.execute("SELECT telegram_id FROM users WHERE role = 'teacher'")
        teachers = c.fetchall()
        conn.commit()
        conn.close()
        
        for teacher in teachers:
            try:
                await context.bot.send_message(teacher[0], f"✍️ Сообщение от родителя {user_name}:\n\n{text}\n\n(ID: {user_id})")
            except:
                pass
        
        await update.message.reply_text("✅ Ваше сообщение отправлено учителю")
        clear_user_context(context)
        return

    # Обработка кнопок меню
    if user_role == 'teacher':
        if text == '📢 Создать объявление':
            clear_user_context(context)
            context.user_data['waiting_for'] = 'announcement'
            await update.message.reply_text("📢 Создание объявления\n\nОтправьте текст объявления:")
        elif text == '📚 Создать домашнее задание':
            clear_user_context(context)
            context.user_data['waiting_for'] = 'homework'
            await update.message.reply_text("📚 Домашнее задание\n\nОтправьте текст домашнего задания:")
        elif text == '📢 Просмотр объявлений':
            clear_user_context(context)
            await show_sent_announcements(update, context)
        elif text == '📚 Просмотр домашних заданий':
            clear_user_context(context)
            await show_sent_homework(update, context)
        elif text == '📋 Управление сообщениями':
            clear_user_context(context)
            await teacher_messages_menu(update, context)
        elif text == '📅 Расписание':
            clear_user_context(context)
            await show_schedule(update, context)
        elif text == '📊 Статистика класса':
            clear_user_context(context)
            conn = sqlite3.connect('classroom.db')
            c = conn.cursor()
            c.execute("SELECT COUNT(*) FROM users WHERE role = 'parent'")
            parents = c.fetchone()[0]
            c.execute("SELECT COUNT(*) FROM users WHERE role = 'teacher'")
            teachers = c.fetchone()[0]
            conn.close()
            await update.message.reply_text(f"📊 Статистика:\nРодителей: {parents}\nУчителей: {teachers}")
        elif text == '💬 Сообщения от родителей':
            clear_user_context(context)
            await show_parent_messages(update, context)
        elif text == '✉️ Написать родителю':
            clear_user_context(context)
            await select_parent_for_message(update, context)
        elif text == '📤 Переслать сообщение':
            clear_user_context(context)
            await show_messages_for_forwarding(update, context)
        elif text == '🔙 Назад':
            clear_user_context(context)
            markup = get_main_menu('teacher')
            await update.message.reply_text("👨‍🏫 Главное меню:", reply_markup=markup)
    
    elif user_role == 'parent':
        if text == '📢 Объявления':
            clear_user_context(context)
            await update.message.reply_text("📢 Здесь отображаются объявления от учителя")
        elif text == '📚 Домашние задания':
            clear_user_context(context)
            await update.message.reply_text("📚 Здесь отображаются домашние задания")
        elif text == '✍️ Написать учителю':
            clear_user_context(context)
            context.user_data['waiting_for'] = 'message_to_teacher'
            await update.message.reply_text("✍️ Напишите ваше сообщение учителю:")
        elif text == '↩️ Ответить учителю':
            clear_user_context(context)
            await show_teacher_messages_for_parent(update, context)
        elif text == '📅 Расписание':
            clear_user_context(context)
            await show_schedule(update, context)
        elif text == '🔙 Назад':
            clear_user_context(context)
            markup = get_main_menu('parent')
            await update.message.reply_text('👨‍👩‍👧 Главное меню:', reply_markup=markup)
    
    elif user_role == 'developer':
        if text in ['👥 Пользователи', '📊 Статистика']:
            clear_user_context(context)
            await admin_panel(update, context)

async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != DEVELOPER_ID:
        return
    
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute("SELECT role, COUNT(*) FROM users GROUP BY role")
    stats = c.fetchall()
    conn.close()
    
    text = "🎛 Панель управления\n\nСтатистика:\n"
    for role, count in stats:
        text += f"• {role}: {count}\n"
    
    await update.message.reply_text(text)

async def make_teacher(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != DEVELOPER_ID or not context.args:
        return
    
    target_id = int(context.args[0])
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute("UPDATE users SET role = 'teacher' WHERE telegram_id = ?", (target_id,))
    conn.commit()
    conn.close()
    
    await update.message.reply_text(f"✅ Пользователь {target_id} назначен учителем")
    try:
        await context.bot.send_message(target_id, "🎉 Вы назначены учителем!\nНажмите /start для обновления меню.")
    except:
        pass

async def make_parent(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != DEVELOPER_ID or not context.args:
        return
    
    target_id = int(context.args[0])
    conn = sqlite3.connect('classroom.db')
    c = conn.cursor()
    c.execute("UPDATE users SET role = 'parent' WHERE telegram_id = ?", (target_id,))
    conn.commit()
    conn.close()
    
    await update.message.reply_text(f"✅ Пользователь {target_id} подтвержден как родитель")
    try:
        await context.bot.send_message(target_id, "🎉 Вы подтверждены как родитель!\nНажмите /start для обновления меню.")
    except:
        pass

def main():
    init_db()
    app = Application.builder().token(BOT_TOKEN).build()
    
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("admin", admin_panel))
    app.add_handler(CommandHandler("make_teacher", make_teacher))
    app.add_handler(CommandHandler("make_parent", make_parent))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_messages))
    
    logger.info(f"Bot starting... Developer ID: {DEVELOPER_ID}")
    app.run_polling()

if __name__ == '__main__':
    main()
5. Зависимости Python
python-telegram-bot==20.7
python-dotenv==1.0.0
6. Команды управления
# Управление сервисом
sudo systemctl start classroom-bot
sudo systemctl stop classroom-bot
sudo systemctl restart classroom-bot
sudo systemctl status classroom-bot
journalctl -u classroom-bot -f

# Управление базой данных
sqlite3 classroom.db
.tables
.schema
SELECT * FROM users;

# Проверка состояния
ps aux | grep bot.py
curl -s https://api.telegram.org/bot8071154944:AAGn5xwhNYQdKwHAsG_FPcnQQSXt9jcmiBg/getMe
Это полная документация без сокращений. Все разделы содержат исчерпывающую информацию о структуре, коде и настройках бота.

